import argparse
import shutil
import time
from pathlib import Path

import emi
import parser

cli_parser = argparse.ArgumentParser()

cli_parser.add_argument('filename')
cli_parser.add_argument(
    '-v', 
    '--verbose', 
    action='store_true',
    help='toggle verbose mode')
cli_parser.add_argument(
    '-n', 
    '--new', 
    action='store_true',
    help='overwrite or create a file instead of patching an .EMI file')
cli_parser.add_argument(
    '-c', 
    '--copy', 
    action='store_true',
    help='copy the file before applying the patch')

def main():
    args = cli_parser.parse_args()
    verbose = args.verbose
    overwrite = args.new
    copy = args.copy
    source_filename = args.filename
    source_path = Path(source_filename)

    if not source_path.exists():
        raise FileNotFoundError(f"Source file {source_filename} not found!")

    with open(source_path, "r") as source_file:
        source = source_file.read()

    if verbose:
        print("Parsing...")

    start_t = time.perf_counter()
    source_tree = parser.parser.parse(source)
    source_transform = parser.SyntaxTransformer().transform(source_tree)
    byte_string, target_filename = parser.Processor().process(source_transform)
    end_t = time.perf_counter()

    if verbose:
        print(f"Parsing completed in {end_t-start_t} seconds.")

    target_path = Path(target_filename)

    if not target_path.exists() and not overwrite:
        raise FileNotFoundError(f"Target file {target_filename} not found!")

    if overwrite:
        with open(target_path, "wb") as target_file:
            target_file.write(byte_string)
    else:
        if copy:
            shutil.copy2(target_filename, target_filename + "_copy")
            target_path = Path(target_filename + "_copy")
        with open(target_path, "r+b") as target_file:
            toc = target_file.read(0x800)
            if not emi.validate(toc):
                raise ValueError(f"Target file {target_filename} is not a valid EMI file!")
            
            toc_entries = emi.browse_toc(toc)
            text_entry = emi.find_toc(toc_entries, b"\x00\x00\x01\x80")

            if text_entry is None:
                raise ValueError(f"Target file {target_filename} does not ontain a text section!")

            if len(byte_string) > text_entry.size + (-text_entry.size % 2048):
                print(len(byte_string), text_entry.size)
                raise ValueError("Generated byte string is too long!")

            target_file.seek(text_entry.start)
            target_file.write(byte_string)

            target_file.seek(text_entry.toc_addr)
            target_file.write(int.to_bytes(len(byte_string), length=4, byteorder="little"))
            target_file.seek(4, 1)
            target_file.write(byte_string[:4])

        print(f"{target_filename} successfully modified")
            


if __name__ == "__main__":
    main()

import shutil
import time
from pathlib import Path

from .emi_tools import validate, browse_toc, find_toc #type: ignore

def editor(source_filename, verbose, overwrite, mode, copy):
    source_path = Path(source_filename)

    if not source_path.exists():
        raise FileNotFoundError(f"Source file {source_filename} not found!")

    with open(source_path, "r") as source_file:
        source = source_file.read()

    if verbose:
        print("Parsing...")

    if mode == "3":
        from .parser3 import parser, SyntaxTransformer, Processor
    elif mode == "4":
        from .parser4 import parser, SyntaxTransformer, Processor

    start_t = time.perf_counter()
    source_tree = parser.parse(source)
    source_transform = SyntaxTransformer().transform(source_tree)
    byte_string, target_filename, original_len = Processor().process(source_transform)
    end_t = time.perf_counter()

    if verbose:
        print(f"Parsing completed in {end_t-start_t} seconds.")

    target_path = Path(target_filename)

    if not target_path.exists() and not overwrite:
        raise FileNotFoundError(f"Target file {target_filename} not found!")

    if overwrite:
        with open(target_path, "wb") as target_file:
            target_file.write(byte_string)
    else:
        if copy:
            shutil.copy2(target_filename, target_filename + "_copy")
            target_path = Path(target_filename + "_copy")
        with open(target_path, "r+b") as target_file:
            toc = target_file.read(0x800)
            if not validate(toc):
                raise ValueError(f"Target file {target_filename} is not a valid EMI file!")
            
            toc_entries = browse_toc(toc)
            text_entry = find_toc(toc_entries, b"\x00\x00\x01\x80")

            if text_entry is None:
                raise ValueError(f"Target file {target_filename} does not ontain a text section!")

            if len(byte_string) > text_entry.size + (-text_entry.size % 2048):
                print(len(byte_string), text_entry.size)
                raise ValueError("Generated byte string is too long!")

            target_file.seek(text_entry.start)
            target_file.write(byte_string)

            target_file.seek(text_entry.toc_addr)
            target_file.write(int.to_bytes(original_len, length=4, byteorder="little"))
            target_file.seek(4, 1)
            target_file.write(byte_string[:4])

        print(f"{target_filename} successfully modified")
